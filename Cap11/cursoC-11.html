<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <meta http-equiv="CONTENT-TYPE"
 content="text/html; charset=iso-8859-1">
  <title>11. Entrada/salida</title>
  <meta name="GENERATOR" content="StarOffice/5.2 (Linux)">
  <meta name="AUTHOR" content="Eduardo Grosclaude">
  <meta name="CREATED" content="20010527;14472300">
  <meta name="CHANGEDBY" content="Eduardo Grosclaude">
  <meta name="CHANGED" content="20010818;10564800">
  <style>
	<!--
		PRE { margin-left: 0.4cm }
	-->
	</style>
</head>
<body>
<h1>11. Entrada/Salida</h1>
<p align="justify">El concepto de entrada/salida en C replica el de su
ambiente nativo, el sistema operativo UNIX, donde todos los archivos
son vistos como una sucesi&oacute;n de bytes, prescindiendo
completamente de su contenido, organizaci&oacute;n o forma de acceso.
Adem&aacute;s, en UNIX los dispositivos de entrada o salida llevan
asociados archivos l&oacute;gicos, que son puntos de entrada
implementados en software a dichos dispositivos. Toda la
comunicaci&oacute;n
entre un programa y el mundo externo, ya sean archivos f&iacute;sicos
o l&oacute;gicos, se hace mediante las mismas funciones.</p>
<p align="justify">Lo anterior da como resultado que la
abstracci&oacute;n
de programaci&oacute;n para los archivos en C es simplemente un <b>flujo</b>
de bytes o <b>stream</b>, que se maneja con operaciones primitivas
independientemente de cu&aacute;l sea su origen y su destino.</p>
<p align="justify">Si bien el C no contiene palabras reservadas de
entrada/salida (<b>E/S</b>), la biblioteca standard s&iacute; provee
un rico conjunto de funciones de E/S, tan amplio que suele provocar
confusi&oacute;n en quienes se aproximan por primera vez al lenguaje.
Ofreceremos primeramente un resumen de las funciones de E/S standard
y nos concentraremos luego en la E/S sobre archivos. Aunque la
informaci&oacute;n dada aqu&iacute; es suficiente para intentar la
creaci&oacute;n de programas simples, la E/S es un tema notablemente
complejo, y es aconsejable tener a mano el manual de las funciones C
de su sistema.</p>
<p align="justify">Para orientaci&oacute;n del lector agregamos un mapa
de la lecci&oacute;n presente.</p>
<table border="1" bordercolor="#000000" cellpadding="4" cellspacing="0"
 width="100%">
  <col width="64*"> <col width="64*"> <col width="64*"> <col
 width="64*"> <thead> <tr>
    <th colspan="4" valign="top" width="100%">
    <p align="center">Funciones de entrada/salida</p>
    </th>
  </tr>
  </thead> <tbody>
    <tr valign="top">
      <td rowspan="2" width="25%">
      <p align="center"><b>E/S standard</b></p>
      <p align="center">de caracteres</p>
      <p align="center">de l&iacute;neas</p>
      <p align="center">con formato </p>
      <p align="center">sobre strings</p>
      </td>
      <td colspan="3" width="75%">
      <p align="center"><b>Sobre archivos</b></p>
      </td>
    </tr>
    <tr valign="top">
      <td width="25%">
      <p align="center"><b>ANSI C</b></p>
      <p align="center">de caracteres</p>
      <p align="center">de l&iacute;neas</p>
      <p align="center">con formato</p>
      </td>
      <td width="25%">
      <p align="center"><b>De acceso directo</b></p>
      </td>
      <td width="25%">
      <p align="center"><b>POSIX</b></p>
      </td>
    </tr>
  </tbody>
</table>
<p align="justify"><br>
</p>
<h2 align="justify"><a name="funciones de ES std"></a>Funciones de E/S
standard</h2>
<p align="justify">Los programas C reciben tres canales de
comunicaci&oacute;n
con el ambiente abiertos antes de comenzar su ejecuci&oacute;n. El
uso t&iacute;pico de estos canales de comunicaci&oacute;n es la
lectura del teclado y la impresi&oacute;n sobre pantalla, aunque si
el sistema operativo lo soporta, tambi&eacute;n posibilitan la
poderosa t&eacute;cnica de la redirecci&oacute;n. La biblioteca
standard provee funciones m&iacute;nimas para estos usos, quedando
fuera de consideraci&oacute;n algunas caracter&iacute;sticas
indispensables en programas de producci&oacute;n, como seguridad,
validaci&oacute;n, o la posibilidad de organizar la salida en
pantalla. Por ejemplo, no hay una forma can&oacute;nica de borrar la
pantalla en C, ya que &eacute;sta es una funci&oacute;n que depende
fuertemente de la plataforma donde se ejecute el programa. Las
caracter&iacute;sticas faltantes en la E/S standard se compensan
recurriendo a bibliotecas de terceras partes.</p>
<h3 align="justify">E/S standard de caracteres</h3>
<p align="justify">Las funciones de E/S standard de caracteres son<b>
getchar()</b><span style=""> y </span><b>putchar().</b>
El ejemplo siguiente es un programa que copia la entrada en la salida
car&aacute;cter a car&aacute;cter. Puede usarse, con
redirecci&oacute;n,
para crear o copiar archivos, como un clon del comando <b>cat</b> de
UNIX.</p>
<pre
 style="text-align: justify; color: rgb(0, 153, 0); font-weight: bold;">#include &lt;stdio.h&gt;<br>main()<br>{<br>    int a;<br>    while((a = getchar()) != EOF) <br>        putchar(a);<br>}</pre>
<h3 align="justify">E/S standard de l&iacute;neas</h3>
<p align="justify">Las funciones <b>gets()</b> y <b>puts()</b> leen
de
teclado e imprimen, respectivamente, l&iacute;neas de caracteres
terminadas por la se&ntilde;al de fin de l&iacute;nea <b>\n</b>. La
funci&oacute;n gets() debe recibir como argumento la direcci&oacute;n
de un buffer o zona de memoria donde depositar los caracteres
provenientes de entrada standard. Estos son normalmente tipeados por
el usuario, pero pueden provenir de archivos o ser resultado de la
ejecuci&oacute;n -eventualmente concurrente- de otros programas,
gracias a la redirecci&oacute;n. Es un error muy frecuente ofrecer a
gets() un puntero no inicializado. <a
 href="../Cap10b/cursoC-10b.html#gets" target="_blank"><span
 style="text-decoration: none;">La
funci&oacute;n gets() </span></a>se ha descripto en la unidad sobre
apuntadores y direcciones.</p>
<h3 align="justify">Ejemplo</h3>
<p align="justify">El mismo programa, pero orientado a copiar un stream
de texto l&iacute;nea por l&iacute;nea. La constante BUFSIZ est&aacute;
definida en stdio.h y es el tama&ntilde;o del buffer de estas
funciones. Se puede sugerir esta elecci&oacute;n para el buffer del
programa, salvo que haya motivos para proporcionar otro tama&ntilde;o.</p>
<pre
 style="text-align: justify; color: rgb(0, 153, 0); font-weight: bold;">#include &lt;stdio.h&gt;<br>main()<br>{<br>    char area[BUFSIZ];<br>    while(gets(area) != NULL)<br>        puts(area);<br>}</pre>
<p align="justify">La funci&oacute;n gets() elimina el \n final con que
termina la l&iacute;nea
antes de almacenarla en su buffer. La funci&oacute;n puts() lo
repone.</p>
<p align="justify">Hay que subrayar que, como el tama&ntilde;o del
buffer no es argumento para la funci&oacute;n gets(), &eacute;sta <b>no
conoce los l&iacute;mites</b> del &aacute;rea de memoria de que
dispone para dejar los resultados de una operaci&oacute;n de entrada,
y por lo tanto no puede hacer verificaci&oacute;n en tiempo de
ejecuci&oacute;n. Podr&iacute;a ocurrir que una l&iacute;nea de
entrada superara el tama&ntilde;o del buffer: entonces esta entrada
corromper&aacute; alg&uacute;n otro contenido del espacio del
programa. Esta condici&oacute;n se conoce como <i>buffer overflow</i>
y el comportamiento en este caso queda indefinido, dando lugar,
inclusive, a problemas de seguridad. Por este motivo gets() no es
utilizada en programas de producci&oacute;n.</p>
<h3>E/S standard con formato</h3>
<p align="justify">Las funciones <b>printf() </b><span style="">y
</span><b>scanf()</b> permiten imprimir e ingresar, respectivamente,
conjuntos de datos <b>en formato legible</b>, descriptos por cadenas
de formato. Las cadenas se componen de especificaciones de
conversi&oacute;n
y son sim&eacute;tricamente las mismas para ambas funciones. La
<a href="../Cap3/cursoC-3.html#printf" target="_blank"><span
 style="text-decoration: none;">funci&oacute;n
printf() y las cadenas de formato</span></a> han sido descriptas en
la unidad correspondiente a tipos de datos.</p>
<p align="justify">Inversamente a printf(), la funci&oacute;n scanf()
buscar&aacute; en la entrada standard patrones de acuerdo a las
especificaciones de conversi&oacute;n. Generar&aacute;
representaciones internas para los datos le&iacute;dos y los
almacenar&aacute; en variables. Para esto debe recibir las
<b>direcciones</b> de dichas variables donde almacenar los elementos
detectados en la entrada standard. Es un error frecuente ofrecerle,
como argumentos, las variables, y no las <b>referencias</b> a las
mismas.</p>
<h3 align="justify">Ejemplo</h3>
<pre
 style="text-align: justify; color: rgb(0, 153, 0); font-weight: bold;">main()<br>{<br>    int a, long b;<br>    if(scanf("%d %ld", &amp;a, &amp;b) != 2)<br>        exit(1);<br>    printf("a=%d, b=%ld\n", a, b);<br>}</pre>
<p align="justify">El valor devuelto por scanf() es la cantidad de
datos le&iacute;dos y
convertidos exitosamente, y deber&iacute;a siempre comprobarse que es
igual a lo esperado.</p>
<p align="justify">El uso de scanf() es generalmente
problem&aacute;tico.
La funci&oacute;n scanf() consumir&aacute; toda la entrada posible,
pero se detendr&aacute; al encontrar un error (una entrada que no
corresponda a lo descripto por la especificaci&oacute;n de
conversi&oacute;n) y dejar&aacute; el resto de la entrada sin
procesar, en el buffer de entrada. Si luego otra funci&oacute;n de
entrada intenta leer, se encontrar&aacute; con esta entrada no
consumida, lo cual puede dar origen a problemas de ejecuci&oacute;n
dif&iacute;ciles de diagnosticar. El error parecer&aacute; producirse
en una instrucci&oacute;n posterior a la invocaci&oacute;n de scanf()
culpable. Por esta raz&oacute;n suele ser dif&iacute;cil mezclar el
uso de scanf() con otras funciones de entrada/salida. Adem&aacute;s,
no hay manera directa de validar que la entrada quede en el rango del
tipo de datos destino. </p>
<p align="justify">El uso m&aacute;s recomendable de scanf() es cuando
se la utiliza para leer, mediante redirecci&oacute;n, un flujo
generado autom&aacute;ticamente por otro programa (y que, por lo
tanto, tiene una gram&aacute;tica rigurosa y conocida). </p>
<h3 align="justify">E/S standard sobre strings</h3>
<p align="justify">La misma l&oacute;gica de las funciones de E/S con
formato sirve para que otras funciones lean variables con formato de
un string, o impriman variables formateadas sobre una cadena. El
efecto de <b>sprintf() </b>sobre su cadena argumento es el mismo que
tendr&iacute;a printf() sobre salida standard. Por su parte <b>sscanf()
</b><span style="">lee de un string <b>en memoria</b>,
conteniendo datos en formato legible, y los recoge en
representaci&oacute;n
binaria en variables, lo mismo que si scanf() los hubiera le&iacute;do
de entrada standard.</span></p>
<h3 align="justify">Ejemplo</h3>
<pre
 style="text-align: justify; font-weight: bold; color: rgb(0, 153, 0);">main()<br>{<br>    char area[1024];<br>    int a; long b;<br>    sprintf(area, "%d %ld\n", -6534, 1273632);<br>    sscanf(area, "%d %ld", &amp;a, &amp;b);<br>    printf("%d %ld\n", a, b);<br>}</pre>
<p align="justify">El resultado deber&iacute;a ser:</p>
<pre
 style="margin-bottom: 0.5cm; text-align: justify; color: rgb(204, 0, 0); font-weight: bold;">-6534 1273632</pre>
<h2 align="justify"><a name="ES sobre archivos"></a>E/S sobre archivos</h2>
<p align="justify">Diferentes sistemas operativos tienen diferentes
<b>sistemas de archivos</b> y diferentes <b>modelos de archivos</b>.
Los sistemas de archivos son los conjuntos de funciones particulares
que cada sistema ofrece para acceder a los archivos y a la estructura
de directorios que soporta. Los modelos de archivos son aquellas
convenciones de formato u organizaci&oacute;n que son particulares de
un sistema operativo o plataforma.</p>
<p align="justify">Por ejemplo, tanto DOS como UNIX soportan la
noci&oacute;n
de archivo de texto, pero con algunas diferencias a nivel de modelo
de archivos. En ambos, un archivo de texto es una secuencia de
l&iacute;neas
de texto, donde cada l&iacute;nea es una secuencia de caracteres
terminado en fin de l&iacute;nea; pero en DOS, la convenci&oacute;n
de fin de l&iacute;nea es un par de caracteres (CR,LF) (equivalentes
a ASCII 13 y 10) mientras que para UNIX, un fin de l&iacute;nea
equivale solamente a LF (ASCII 10). Adem&aacute;s DOS soporta la
noci&oacute;n de car&aacute;cter de fin de archivo (EOF o ASCII 26)
mientras que no hay tal concepto en UNIX.</p>
<p align="justify">Por otro lado, diferentes sistemas de archivo
proveen diferentes vistas sobre diferentes implementaciones. Un
sistema operativo puede soportar o no la noci&oacute;n de directorio,
o la de links m&uacute;ltiples; o puede fijar determinadas
condiciones sobre los nombres de archivos, todo esto en funci&oacute;n
de la organizaci&oacute;n &iacute;ntima de sus estructuras de datos.</p>
<p align="justify">Siendo un objetivo de dise&ntilde;o del lenguaje C
el favorecer la producci&oacute;n de programas portables, el C
contempla la forma de resolver estos problemas de manera f&aacute;cil
para los programadores. Las funciones de entrada/salida sobre
archivos de la biblioteca standard est&aacute;n divididas en dos
grandes regiones: el conjunto de funciones del C standard,
tambi&eacute;n
llamadas funciones de entrada/salida <b>bufferizada</b>, definidas
por ANSI, y las funciones POSIX, tambi&eacute;n llamadas funciones de
entrada/salida <b>de bajo nivel.</b></p>
<p align="justify">Las funciones ANSI C tienen el objetivo de ocultar a
los programas las particularidades de la plataforma, haci&eacute;ndolos
plenamente portables a pesar de las diferencias conceptuales y de
implementaci&oacute;n de entrada/salida entre los diferentes sistemas
operativos. Estas funciones resuelven, por ejemplo, el cl&aacute;sico
problema de las diferentes convenciones sobre los delimitadores de un
archivo de texto. Es decir, est&aacute;n orientadas a resolver los
problemas de incompatibilidad inherentes al <b>modelo de archivos</b>.
En cambio, el esfuerzo de estandarizaci&oacute;n de POSIX apunta a
establecer (aunque no solamente en lo referente a los archivos) una
interfaz uniforme entre compilador y sistema operativo, proveyendo
primitivas de acceso a los archivos con un comportamiento claramente
determinado, independientemente de cu&aacute;l sea el sistema
operativo subyacente. As&iacute;, las funciones POSIX resuelven
problemas de consistencia entre diferentes <b>sistemas de archivos</b>.
</p>
<p align="justify">Las funciones del ANSI C son las m&aacute;s
com&uacute;nmente utilizadas por el programador, pero se apoyan en
funcionalidad suministrada por las funciones POSIX (de nivel m&aacute;s
bajo), que tambi&eacute;n est&aacute;n disponibles y son las
recomendadas cuando las restricciones del problema exceden a las
funciones ANSI. La caracter&iacute;stica fundamental de las funciones
ANSI es la entrada/salida <i>bufferizada.</i><span
 style="font-style: normal;">
Por ejemplo</span>, una operaci&oacute;n de escritura solicitada por
una instrucci&oacute;n del programa no se efectiviza inmediatamente
sino que se realiza sobre un buffer intermedio, administrado por las
funciones de biblioteca standard y con su pol&iacute;tica propia de
<i>flushing</i> o descarga al dispositivo. En cambio, las funciones
POSIX hacen E/S directa a los dispositivos (o al menos, al sistema de
E/S del sistema operativo) y por esto son las preferidas para la
programaci&oacute;n de drivers, servidores, etc., donde la
performance y otros detalles finos deban ser controlados m&aacute;s
directamente por el programa.</p>
<table border="0" cellpadding="4" cellspacing="0" width="100%">
  <col width="128*"> <col width="128*"> <thead> <tr>
    <td width="50%">
    <div style="text-align: left;"> </div>
    <p style="text-align: left;"><big><font size="2"><big>Las funciones
de entrada/salida bufferizada reciben argumentos a imprimir y los van
depositando en un buffer o zona de memoria intermedia. </big></font> </big></p>
    <div style="text-align: left;"><big> </big></div>
    <p style="text-align: left;"><big><font size="2"><big>Cuando el
buffer se llena, o cuando aparece un car&aacute;cter de fin de
l&iacute;nea, el buffer se descarga al dispositivo,
escribi&eacute;ndose los contenidos del buffer en pantalla, disco, etc.</big></font></big></p>
    </td>
    <td valign="top" width="50%">
    <p><img alt="" src="img/iobuffer.gif" name="Imagen1"
 style="border: 0px solid ; width: 425px; height: 425px;" align="left"><br
 clear="left">
    <br>
    </p>
    </td>
  </tr>
  </thead>
</table>
<h2 align="justify"><a name="ANSI C ES archivos"></a>Funciones ANSI C
de E/S sobre archivos </h2>
<p align="justify">Las funciones ANSI realizan todas las operaciones
sobre archivos por medio de una estructura o bloque de control cuyo
tipo en C se llama <b>FILE</b>. Esta estructura est&aacute; definida
en el header <b>stdio.h</b><span style=""> y
contiene, entre otras cosas, punteros a buffers para escritura y
lectura. La primera operaci&oacute;n necesaria es la <b>apertura</b>
del archivo, que construye una estructura FILE, la inicializa con
valores adecuados y devuelve un apuntador a la misma. El apuntador
servir&aacute; para referenciarla durante todo el trabajo con el
archivo y hasta que deba ser cerrado.</span></p>
<p style="" align="justify">En la apertura del
archivo corresponde indicar el <b>modo de acceso</b> (la clase de
operaciones que se van a a hacer sobre &eacute;l). Como algunos
sistemas operativos (notoriamente, el DOS) distinguen entre archivos
de texto y binarios, el ANSI C provee dos formas de apertura, para
indicar c&oacute;mo se va a tratar el archivo. Cuando un archivo se
abre en <b>modo de texto</b>, durante las operaciones de lectura y
escritura se aplicar&aacute;n las conversiones de fines de l&iacute;nea
y de fin de archivo propias de la plataforma. Para los archivos
abiertos en <b>modo binario</b>, no se aplicar&aacute;n conversiones.
</p>
<p style="" align="justify">En sistemas conformes a
POSIX, como UNIX, no hay realmente diferencia entre los dos modos de
apertura. Si se desea <font size="3">especificar una apertura de
archivo en modo binario (para asegurar la portabilidad) se a&ntilde;ade
una <b><font face="Courier">b</font> </b>a la especificaci&oacute;n
de modo (por ejemplo, como en <font face="Courier">"wb+"</font><font
 face="Times, sans-serif">).</font></font></p>
<p style="" align="justify"><font face="Times, sans-serif"><font
 size="3">En
el cuadro siguiente se resumen las especificaciones de modos de
acceso en apertura de archivos. </font></font>
</p>
<h3>Modos de acceso</h3>
<table border="1" bordercolor="#000000" cellpadding="9" cellspacing="0"
 rules="rows" width="100%">
  <col width="23*"> <col width="233*"> <tbody>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" height="36"
 width="9%">
      <p align="justify"><font face="Courier New, sans-serif"><font
 size="2">"r"</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="91%">
      <p align="justify"><font size="2">Abre un archivo que ya existe
para lectura. La lectura se realiza al inicio del archivo.</font></p>
      </td>
    </tr>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" height="37"
 width="9%">
      <p align="justify"><font face="Courier New, sans-serif"><font
 size="2">"w"</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="91%">
      <p align="justify"><font size="2">Se crea un nuevo archivo para
escribir. Si el archivo existe, se inicializa y se sobreescribe.</font></p>
      </td>
    </tr>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" height="37"
 width="9%">
      <p align="justify"><font face="Courier New, sans-serif"><font
 size="2">"a"</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="91%">
      <p align="justify"><font size="2">Abre un archivo que ya existe
para agregar informaci&oacute;n al final. S&oacute;lo se puede escribir
a partir del final.</font></p>
      </td>
    </tr>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" height="37"
 width="9%">
      <p align="justify"><font face="Courier New, sans-serif"><font
 size="2">"r+"</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="91%">
      <p align="justify"><font size="2">Abre un archivo que ya existe
para actualizarlo (tanto para lectura como para escritura).</font></p>
      </td>
    </tr>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" height="37"
 width="9%">
      <p align="justify"><font face="Courier New, sans-serif"><font
 size="2">"w+"</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="91%">
      <p align="justify"><font size="2">Crea un nuevo archivo para
actualizarlo (lectura y escritura); si existe, lo sobreescribe.</font></p>
      </td>
    </tr>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" height="36"
 width="9%">
      <p align="justify"><font face="Courier New, sans-serif"><font
 size="2">"a+"</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="91%">
      <p align="justify"><font size="2">Abre un archivo para
a&ntilde;adir informaci&oacute;n al final. Si no existe, lo crea.</font></p>
      </td>
    </tr>
  </tbody>
</table>
<p style="" align="justify"><font size="3">Como en la
entrada/salida standard, para manejar archivos tenemos funciones para
E/S de caracteres, de l&iacute;neas y con formato.</font></p>
<h3 align="justify">Funciones ANSI C de caracteres sobre archivos </h3>
<p style="" align="justify">Las funciones son
<b>fgetc()</b> y <b>fputc()</b>. Ejemplo que copia un archivo:</p>
<pre
 style="text-align: justify; color: rgb(0, 153, 0); font-weight: bold;">#include &lt;stdio.h&gt;<br>main()<br>{<br>    FILE *fp1, *fp2;<br>    int a;<br>    if(((fp1 = fopen("ejemplo.txt","r")) == NULL) || <br>                    ((fp2 = fopen("copia.txt","w")) == NULL))<br>        exit(1);<br>    while((a = fgetc(fp1)) != EOF)<br>        fputc(a, fp2);<br>    fclose(fp1);<br>    fclose(fp2);<br>}</pre>
<p style="" align="justify">Hay otras funciones dentro de esta
categor&iacute;a, como <b>ungetc()</b>
que devuelve un car&aacute;cter al flujo de donde se ley&oacute;.</p>
<h3 align="justify">Funciones ANSI C de l&iacute;neas sobre archivos</h3>
<p align="justify">Mismo ejemplo, en base a l&iacute;neas, con las
funciones <b>fgets()</b><span style=""> y </span><b>fputs()</b>.
La declaraci&oacute;n de variables FILE * y las sentencias de
apertura y cierre de archivos son id&eacute;nticas al caso anterior.
Enunciamos solamente el lazo principal. </p>
<pre style="text-align: justify;">   <span
 style="color: rgb(0, 153, 0); font-weight: bold;"> char area[BUFSIZ];</span><br
 style="color: rgb(0, 153, 0); font-weight: bold;"><span
 style="color: rgb(0, 153, 0); font-weight: bold;">    while(fgets(area, BUFSIZ, fp1) != NULL)</span><br
 style="color: rgb(0, 153, 0); font-weight: bold;"><span
 style="color: rgb(0, 153, 0); font-weight: bold;">        fputs(area, fp2);</span></pre>
<h3 align="justify">Funciones ANSI C con formato sobre archivos</h3>
<p align="justify">Existen funciones <b>fprintf()</b> y <b>fscanf()</b>,
casi id&eacute;nticas a printf() y scanf(), pero donde se especifica
el stream de entrada o de salida. Las funciones printf() y scanf()
pueden verse como el caso particular de las primeras donde el stream
es <b>stdout</b> o <b>stdin</b>, respectivamente.</p>
<h3 align="justify">Ejemplo</h3>
<pre
 style="text-align: justify; color: rgb(0, 153, 0); font-weight: bold;">#include &lt;stdio.h&gt;<br>main()<br>{<br>    FILE *fp1, *fp2;<br>    int a; long b;<br>    if(((fp1 = fopen("ejemplo.txt","r")) == NULL) || <br>                    ((fp2 = fopen("copia.txt","w")) == NULL))<br>        exit(1);<br>    if(fscanf(fp1, "%d %ld", &amp;a, &amp;b) != 2)<br>        exit(1);<br>    fprintf(fp2, "%d %ld\n", a, b);<br>    fclose(fp1);<br>    fclose(fp2);<br>}</pre>
<p align="justify">El programa del ejemplo lee dos variables de un
archivo y las
escribe, en el mismo formato, en un segundo archivo.</p>
<h2 align="justify"><a name="ANSI C acceso directo"></a>Funciones ANSI
C de acceso directo</h2>
<p align="justify">Un conjunto muy &uacute;til de funciones ANSI
permite el <b>acceso directo, aleatorio</b>, o <b>random</b>, sobre
archivos, saltando por encima del modelo de E/S secuencial que domina
al resto de las funciones. Las funciones b&aacute;sicas de acceso
directo son <b>fread()</b><span style=""> y
</span><b>fwrite()</b>, que leen bloques de un tama&ntilde;o dado y
en una cantidad dada. Son ideales para lectura y escritura directa de
estructuras de datos, ya se trate de elementos individuales u
organizados en arreglos. Al poder posicionarse el puntero de lectura
o escritura en zonas arbitrarias de los archivos, se logra la
capacidad de E/S por registros con acceso aleatorio.</p>
<h3 align="justify">Ejemplo</h3>
<pre
 style="text-align: justify; color: rgb(0, 153, 0); font-weight: bold;">struct registro {<br>    int dato1;<br>    long dato2;<br>} datos;<br>...<br>fseek(fp, 10L * sizeof(struct registro), SEEK_SET);<br>fread(&amp;datos, sizeof(struct registro), 1, fp);<br>datos.dato1 = 1;<br>fseek(fp, 5L * sizeof(struct registro), SEEK_SET);<br>fwrite(&amp;datos, sizeof(struct registro), 1, fp);</pre>
<p align="justify">En el ejemplo suponemos que se han grabado en el
archivo varios
registros cuyo formato est&aacute; representado por la estructura de
la variable <b>datos</b>. La funci&oacute;n <b>fseek()</b> posiciona
el puntero de lectura en el <i>offset</i> <b>10 * sizeof(...) </b><span
 style="">(que
debe ser un </span><b>long</b><span style="">)</span>,
significando que necesitamos acceder al registro l&oacute;gico 10 del
archivo. A continuaci&oacute;n se leen tantos bytes como mide un
elemento de datos. Cambiando el tercer argumento de fread() podemos
leer en un solo acceso un vector completo de estas estructuras en
lugar de un elemento individualmente.</p>
<p align="justify">Luego de cambiar un valor del registro se lo vuelve
a grabar, esta vez en un offset distinto (correspondiente al registro
l&oacute;gico 5).</p>
<p align="justify">La constante SEEK_SET indica que el posicionamiento
solicitado debe entenderse como absoluto a partir del principio del
archivo. Otras constantes son SEEK_CUR (posicionamiento a partir del
offset actual) y SEEK_END (a partir del fin del archivo). El offset
proporcionado puede ser negativo.</p>
<h3>Sincronizaci&oacute;n de E/S</h3>
<p align="justify">Una restricci&oacute;n importante de la E/S en ANSI
C es que <b>no se pueden mezclar instrucciones de entrada y de salida
sin que intervenga una operaci&oacute;n intermedia de
posicionamiento</b>. Es decir, una sucesi&oacute;n de invocaciones a
<b>fwrite()</b> puede ser seguida de uno o m&aacute;s <b>fread()</b>,
pero &uacute;nicamente luego de un <b>fseek()</b> entre ambas. La
operaci&oacute;n de posicionamiento resincroniza ambos punteros y su
ausencia puede hacer que se recupere <i>basura</i>.</p>
<p align="justify">Este posicionamiento puede ser nulo, como por
ejemplo en <b>fseek(fp, 0L, SEEK_CUR) </b><span style="">que
no var&iacute;a en absoluto la posici&oacute;n de los punteros, pero
realiza la sincronizaci&oacute;n buscada.</span></p>
<h2 align="justify"><a name="resumen ANSI"></a>Resumen de funciones
ANSI C de E/S </h2>
<p align="justify">Podemos resumir lo visto hasta aqu&iacute; con los
prototipos de las funciones ANSI de E/S en el cuadro siguiente.</p>
<table style="page-break-before: always;" border="1"
 bordercolor="#000000" cellpadding="4" cellspacing="0" width="100%">
  <col width="36*"> <col width="96*"> <col width="124*"> <thead> <tr
 valign="top">
    <th width="14%">
    <p align="justify"><br>
    </p>
    </th>
    <th width="37%">
    <p align="justify">E/S Standard</p>
    </th>
    <th width="49%">
    <p align="justify">E/S sobre archivos</p>
    </th>
  </tr>
  </thead> <tbody>
    <tr>
      <td width="14%">
      <p align="left"><font size="2">De caracteres</font></p>
      </td>
      <td width="37%">
      <p style="margin-bottom: 0.2cm;"><font face="Courier, sans-serif"><font
 style="font-size: 8pt;" size="1">int getchar();</font></font></p>
      <p><font face="Courier, sans-serif"><font style="font-size: 8pt;"
 size="1">int putchar(int c);</font></font></p>
      </td>
      <td width="49%">
      <p style="margin-bottom: 0.2cm;"><font face="Courier, sans-serif"><font
 style="font-size: 8pt;" size="1">int fgetc(FILE *stream);</font></font></p>
      <p><font face="Courier, sans-serif"><font style="font-size: 8pt;"
 size="1">int fputc(int c, FILE *stream);</font></font></p>
      </td>
    </tr>
    <tr>
      <td width="14%">
      <p align="left"><font size="2">De l&iacute;neas</font></p>
      </td>
      <td width="37%">
      <p style="margin-bottom: 0.2cm;"><font face="Courier, sans-serif"><font
 style="font-size: 8pt;" size="1">char *gets(char *s);</font></font></p>
      <p><font face="Courier, sans-serif"><font style="font-size: 8pt;"
 size="1">int puts(const char *s);</font></font></p>
      </td>
      <td width="49%">
      <p style="margin-bottom: 0.2cm;"><font face="Courier, sans-serif"><font
 style="font-size: 8pt;" size="1">char *fgets(char *s, int n, FILE
*stream);</font></font></p>
      <p><font face="Courier, sans-serif"><font style="font-size: 8pt;"
 size="1">int fputs(const char *s, FILE *stream);</font></font></p>
      </td>
    </tr>
    <tr>
      <td width="14%">
      <p align="left"><font size="2">Con formato</font></p>
      </td>
      <td width="37%">
      <p style="margin-bottom: 0.2cm;"><font face="Courier, sans-serif"><font
 style="font-size: 8pt;" size="1">int printf(const char *format, ...);</font></font></p>
      <p><font face="Courier, sans-serif"><font style="font-size: 8pt;"
 size="1">int scanf(const char *format, ...);</font></font></p>
      </td>
      <td width="49%">
      <p style="margin-bottom: 0.2cm;"><font face="Courier, sans-serif"><font
 style="font-size: 8pt;" size="1">int fprintf(FILE *stream, const char
*format, ...);</font></font></p>
      <p><font face="Courier, sans-serif"><font style="font-size: 8pt;"
 size="1">int fscanf(FILE *stream, const char *format, ...);</font></font></p>
      </td>
    </tr>
    <tr>
      <td width="14%">
      <p align="left"><font size="2">Sobre strings</font></p>
      </td>
      <td width="37%">
      <p style="margin-bottom: 0.2cm;"><font face="Courier, sans-serif"><font
 style="font-size: 8pt;" size="1">int sprintf(char *s, const char
*format, ...);</font></font></p>
      <p><font face="Courier, sans-serif"><font style="font-size: 8pt;"
 size="1">int sscanf(char *s, const char *format, ...);</font></font></p>
      </td>
      <td width="49%">
      <p><br>
      </p>
      </td>
    </tr>
    <tr>
      <td width="14%">
      <p style="margin-bottom: 0.2cm;" align="left"><font size="2">De
acceso </font> </p>
      <p align="left"><font size="2">directo</font></p>
      </td>
      <td width="37%">
      <p><br>
      </p>
      </td>
      <td width="49%">
      <p style="margin-bottom: 0.2cm;"><font face="Courier, sans-serif"><font
 style="font-size: 8pt;" size="1">size_t fread(void *ptr, size_t size,
size_t nobj, FILE *stream);</font></font></p>
      <p><font face="Courier, sans-serif"><font style="font-size: 8pt;"
 size="1">size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE
*stream);</font></font></p>
      </td>
    </tr>
  </tbody>
</table>
<p align="justify"><br>
</p>
<h2 align="justify"><a name="POSIX"></a>Funciones POSIX de E/S sobre
archivos </h2>
<p align="justify">Las funciones POSIX son la interfaz directa del
programa con las llamadas al sistema, o <b>system calls</b>. Las
funciones POSIX que operan sobre archivos lo hacen a trav&eacute;s de
<b>descriptores de archivos.</b><span style="">
Estos pertenecen a una tabla de archivos abiertos que tiene cada
proceso o programa en ejecuci&oacute;n y se corresponden con
estructuras de datos del sistema operativo para manejar la escritura
y la lectura en los archivos propiamente dichos.</span></p>
<p style="" align="justify">La tabla de archivos
abiertos de un proceso se inicia con tres archivos abiertos
(correspondientes a los streams de entrada standard, salida standard
y salida standard de errores) que reciben los descriptores
n&uacute;meros
0, 1 y 2 respectivamente. Los archivos que se abren subsiguientemente
van ocupando el siguiente descriptor de archivo libre en esta tabla y
por lo tanto reciben descriptores 3, 4, ..., etc. Cada nueva
operaci&oacute;n de apertura exitosa de un archivo devuelve un nuevo
descriptor. Este n&uacute;mero de descriptor se utiliza durante el
resto de la actividad sobre el archivo.</p>
<p style="" align="justify">Tanto las funciones ANSI
C para archivos como las funciones POSIX de archivos manejan
referencias obtenidas mediante la apertura y utilizadas durante toda
la relaci&oacute;n del programa con el archivo, pero las referencias
son diferentes. La referencia al bloque de control utilizada por las
funciones ANSI es de tipo <b>FILE *</b>, mientras que el descriptor
de archivo POSIX es un <b>int</b>. Por este motivo <b>no se pueden
mezclar</b> las llamadas a funciones de uno y otro grupo.</p>
<p style="" align="justify">Sin embargo, s&iacute;
es cierto que las estructuras de tipo FILE, referenciadas por un FILE
*, como se dijo antes, se apoyan en funcionalidad aportada por
funciones POSIX, y por lo tanto contienen un descriptor de archivo.
Si se tiene un archivo abierto mediante una funci&oacute;n POSIX, es
posible, dado su descriptor, obtener directamente el stream
bufferizado correspondiente para manipularlo con funciones ANSI. Esto
se logra con la funci&oacute;n <b>fdopen()</b>.</p>
<p style="" align="justify">Los programas que
utilicen funciones POSIX deben incluir los headers de biblioteca
standard <b>unistd.h</b> y <b>fcntl.h</b>.</p>
<h3>Ejemplo</h3>
<pre style="color: rgb(0, 153, 0); font-weight: bold;">#include &lt;unistd.h&gt;<br>#include &lt;fcntl.h&gt;<br>main()<br>{<br>    char area[1024]; <br>    int fd1, fd2, bytes;<br>    if((fd1 = open("ejemplo.txt", O_RDONLY)) &lt; 0)<br>        exit(1);<br>    if((fd2 = open("copia.txt", <br>               O_WRONLY|O_CREAT|O_TRUNC, 0660)) &lt; 0)<br>        exit(1);<br>    while(bytes = read(fd1, area, sizeof(area)))<br>        write(fd2, area, bytes);<br>    close(fd1); <br>    close(fd2);<br>}</pre>
<p style="" align="justify">Este programa copia dos archivos usando
funciones POSIX read() y
write() aplicadas a los descriptores obtenidos con open().</p>
<p style="" align="justify">Abre el primer archivo
en modo de s&oacute;lo lectura con el <i>flag</i>, u opci&oacute;n,
O_RDONLY, en tanto que necesita escribir sobre el segundo, por lo
cual utiliza el flag O_WRONLY. Adem&aacute;s, para el segundo
archivo, especifica otros flags que van agregados al primero y que
son O_CREAT (si no existe, se lo crea) y O_TRUNC (si ya existe, se
borran todos sus contenidos). </p>
<p style="" align="justify">Los <i>flags</i> son
nombres simb&oacute;licos para constantes de bits. Todas las
combinaciones de flags posibles pueden expresarse como un OR de bits.
Resumimos los <span style="font-style: normal;">flags</span>
m&aacute;s
importantes existentes para este segundo argumento de open(). </p>
<table border="1" bordercolor="#000000" cellpadding="4" cellspacing="0"
 rules="rows" width="100%">
  <col width="63*"> <col width="193*"> <thead> <tr valign="top">
    <td style="color: rgb(0, 0, 153); font-weight: bold;" width="25%">
    <p><font face="Courier New, sans-serif"><font
 style="font-size: 11pt;" size="2">O_RDONLY</font></font></p>
    </td>
    <td style="color: rgb(0, 0, 153);" width="75%">
    <p><font size="2">El archivo se abre para lectura solamente</font></p>
    </td>
  </tr>
  </thead> <tbody>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" width="25%">
      <p><font face="Courier New, sans-serif"><font
 style="font-size: 11pt;" size="2">O_RDWR</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="75%">
      <p><font size="2">Se abre para escritura solamente</font></p>
      </td>
    </tr>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" width="25%">
      <p><font face="Courier New, sans-serif"><font
 style="font-size: 11pt;" size="2">O_APPEND</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="75%">
      <p><font size="2">El archivo puede ser le&iacute;do o
agreg&aacute;rsele contenido</font></p>
      </td>
    </tr>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" width="25%">
      <p><font face="Courier New, sans-serif"><font
 style="font-size: 11pt;" size="2">O_CREAT</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="75%">
      <p><font size="2">Si el archivo no existe, se lo crea</font></p>
      </td>
    </tr>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" width="25%">
      <p><font face="Courier New, sans-serif"><font
 style="font-size: 11pt;" size="2">O_EXCL</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="75%">
      <p><font size="2">Si ya existe, se vuelve con indicaci&oacute;n
de error</font></p>
      </td>
    </tr>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" width="25%">
      <p><font face="Courier New, sans-serif"><font
 style="font-size: 11pt;" size="2">O_WRONLY</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="75%">
      <p><font size="2">Se abre para escritura solamente</font></p>
      </td>
    </tr>
    <tr valign="top">
      <td style="color: rgb(0, 0, 153); font-weight: bold;" width="25%">
      <p><font face="Courier New, sans-serif"><font
 style="font-size: 11pt;" size="2">O_TRUNC</font></font></p>
      </td>
      <td style="color: rgb(0, 0, 153);" width="75%">
      <p><font size="2">Si existe se destruye antes de crearlo</font></p>
      </td>
    </tr>
  </tbody>
</table>
<p style="" align="justify">El tercer argumento de
open() tiene sentido s&oacute;lo al crear un archivo. Sirve para
especificar los permisos con los que ser&aacute; creado, siempre
seg&uacute;n el concepto de UNIX de permisos de <b>lectura, escritura
y ejecuci&oacute;n</b>, distribuidos en clases de usuarios. Para los
sistemas operativos que no cuentan con estas nociones, el tercer
argumento simplemente se ignora, pero se mantiene la interfaz POSIX
para asegurar la portabilidad de los programas.</p>
<p style="" align="justify">N&oacute;tese que las
funciones ANSI C no permiten la especificaci&oacute;n de estos
permisos de creaci&oacute;n.</p>
<p style="" align="justify">Como para los flags, hay
algunas constantes de bits &uacute;tiles.</p>
<table border="1" bordercolor="#000000" cellpadding="4" cellspacing="0"
 width="100%">
  <col width="54*"> <col width="74*"> <col width="64*"> <col
 width="64*"> <thead> <tr valign="top">
    <th width="21%">
    <p><br>
    </p>
    </th>
    <th width="29%">
    <p>Due&ntilde;o</p>
    </th>
    <th width="25%">
    <p>Grupo</p>
    </th>
    <th width="25%">
    <p>Otros</p>
    </th>
  </tr>
  </thead> <tbody>
    <tr valign="top">
      <td width="21%">
      <p><font size="2">Lectura</font></p>
      </td>
      <td width="29%">
      <p style=""><font face="Courier New, sans-serif"><font size="2">S_IRUSR
(S_IREAD)</font></font></p>
      </td>
      <td width="25%">
      <p style="" align="left"><font face="Courier New, sans-serif"><font
 size="2">S_IRGRP</font></font></p>
      </td>
      <td width="25%">
      <p style=""><font face="Courier New, sans-serif"><font size="2">S_IROTH</font></font></p>
      </td>
    </tr>
    <tr valign="top">
      <td width="21%">
      <p><font size="2">Escritura</font></p>
      </td>
      <td width="29%">
      <p style=""><font face="Courier New, sans-serif"><font size="2">S_IWUSR
(S_IWRITE)</font></font></p>
      </td>
      <td width="25%">
      <p style="" align="left"><font face="Courier New, sans-serif"><font
 size="2">S_IWGRP</font></font></p>
      </td>
      <td width="25%">
      <p style=""><font face="Courier New, sans-serif"><font size="2">S_IWOTH</font></font></p>
      </td>
    </tr>
    <tr valign="top">
      <td width="21%">
      <p><font size="2">Ejecuci&oacute;n</font></p>
      </td>
      <td width="29%">
      <p style=""><font face="Courier New, sans-serif"><font size="2">S_IXUSR
(S_IEXEC)</font></font></p>
      </td>
      <td width="25%">
      <p style=""><font face="Courier New, sans-serif"><font size="2">S_IXGRP</font></font></p>
      </td>
      <td width="25%">
      <p style=""><font face="Courier New, sans-serif"><font size="2">S_IXOTH</font></font></p>
      </td>
    </tr>
    <tr valign="top">
      <td width="21%">
      <p><font size="2">Los tres permisos</font></p>
      </td>
      <td width="29%">
      <p style="" align="justify"><font face="Courier New, sans-serif"><font
 size="2">S_IRWXU</font></font></p>
      </td>
      <td width="25%">
      <p style=""><font face="Courier New, sans-serif"><font size="2">S_IRWXG</font></font></p>
      </td>
      <td width="25%">
      <p style=""><font face="Courier New, sans-serif"><font size="2">S_IRWXO</font></font></p>
      </td>
    </tr>
  </tbody>
</table>
<h3>Ejemplo</h3>
<pre style="color: rgb(0, 153, 0); font-weight: bold;">int fd = open("prueba.dat", O_RDWR|O_CREAT, S_IRWXU|S_IRGRP);</pre>
<p>Si el archivo prueba.dat no existe, se lo crea; se abre para
lectura y escritura y con todos los permisos para el creador, pero
s&oacute;lo con permiso de lectura para el grupo del due&ntilde;o. El
resto de los usuarios no tiene ning&uacute;n permiso sobre el
archivo.</p>
<p>Para posicionar el puntero de lectura/escritura en un offset
determinado, existe la funci&oacute;n <b>lseek()</b>. El origen del
desplazamiento se expresa, como en las funciones ANSI C de acceso
directo, con las constantes SEEK_SET, SEEK_END y SEEK_CUR.</p>
<h3>Ejemplo</h3>
<p>Repetimos el ejemplo dado para las funciones ANSI donde se lee el
registro l&oacute;gico n&uacute;mero 10 y tras una modificaci&oacute;n
se lo copia en el registro l&oacute;gico 5, esta vez con funciones
POSIX.</p>
<pre style="text-align: left; color: rgb(0, 153, 0); font-weight: bold;">lseek(fd, 10L * sizeof(struct registro), SEEK_SET);<br>read(fd, &amp;datos, sizeof(struct registro));<br>datos.dato1 = 1;<br>lseek(fd, 5L * sizeof(struct registro), SEEK_SET);<br>write(fd, &amp;datos, sizeof(struct registro));</pre>
<p><br>
<br>
</p>
<hr>
<h2><a name="ejercicios"></a>Ejercicios</h2>
<p>1. Escribir una funci&oacute;n que copie la entrada en la salida
pero eliminando las vocales.</p>
<p>2. Escribir una funci&oacute;n que reemplace los caracteres no
imprimibles por caracteres <b>punto</b>. </p>
<p>3.&nbsp; Construir un programa que cuente la cantidad de palabras de
un
archivo, separadas por blancos, tabuladores o fin de l&iacute;nea.</p>
<p>4. Construir un programa que cuente la cantidad de caracteres y de
l&iacute;neas de un archivo.</p>
<p>5.&nbsp; Construir un programa que permita eliminar de un archivo
las
l&iacute;neas que contengan una cadena dada.</p>
<p>6.. Escribir una funci&oacute;n que reciba como argumento dos
enteros y devuelva un string de formato conteniendo una m&aacute;scara
de formato apropiada para imprimir un n&uacute;mero en punto
flotante. Por ejemplo, si se le dan como argumentos 7 y 2,
deber&aacute;
devolver el string "%7.2f". Aplicar la funci&oacute;n para
imprimir n&uacute;meros en punto flotante.</p>
<p>7. Escribir sobre un archivo una variable int con valor 1 y una
variable long con valor 2. Hacerlo primero con funciones de E/S con
formato, y luego con funciones de acceso directo. Examinar en cada
caso el resultado visualizando el archivo y opcionalmente con el
comando <b>od -bc</b><span style="">.</span></p>
<p style="">8. Defina una estructura b&aacute;sica
simple para un registro, a su gusto. Puede ser un registro de
informaci&oacute;n personal, bibliogr&aacute;fica, etc. Construya
funciones para leer estos datos del teclado e imprimirlos en
pantalla. Luego, usando funciones ANSI C, construya funciones para
leer y escribir una de estas estructuras en un archivo, dado un
n&uacute;mero de registro l&oacute;gico determinado.</p>
<p style="">9. Repita el ejercicio anterior
reemplazando las funciones ANSI C por funciones POSIX.</p>
<p style="">10. Construya programas que utilicen
las funciones anteriores, ANSI C o POSIX, y ofrezcan un men&uacute;
de operaciones de administraci&oacute;n: cargar un dato en el
archivo, imprimir los datos contenidos en una posici&oacute;n
determinada, listar la base generada completa, eliminar un registro,
etc.</p>
<br>
<pre><a href="adicionales/adic11.html#adic1">Ejercicios Adicionales<br><br></a><br><a
 href="adicionales/adic11.html#adic2">Ejercicios Avanzados<br></a><br><br></pre>
<hr style="width: 100%; height: 2px;">
<p><br>
<br>
</p>
</body>
</html>
