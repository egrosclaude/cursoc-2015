
\chapter{Propiedades de las variables}

Las variables tienen diferentes propiedades según que sean declaradas dentro o fuera de las funciones,
y según ciertos modificadores utilizados al declararlas. Entre las propiedades de las variables
distinguimos:

\begin{itemize}
	\item Alcance (desde dónde es visible una variable)
	\item Vida (cuándo se crea y cuándo desaparece)
	\item Clase de almacenamiento (dónde y cómo se aloja la información que contiene)
	\item Liga o \textit{linkage} (en qué forma puede ser manipulada por el linker)
\end{itemize}

Las reglas que determinan, a partir de la declaración de una variable, cuáles serán sus propiedades, son
bastante complejas. Estas reglas son tan interdependientes, que necesariamente la discusión de las
propiedades de las variables será algo reiterativa.

\section{Alcance de las variables}

Una declaración puede aparecer, o bien dentro de una función, o bien fuera de todas ellas. En el primer
caso, hablamos de una \textbf{variable local}; en el segundo, se trata de una variable \textbf{externa, o global}, y las
diferencias entre ambas son muchas e importantes. Por supuesto, la primera consecuencia del lugar de declaración es el \textbf{alcance}, o ámbito de visibilidad de la variable: una variable local \textbf{es visible sólo desde dentro de la función} donde
es declarada. Una variable externa puede ser usada \textbf{desde cualquier función de la unidad de traducción},
siendo suficiente que la declaración se encuentre antes que el uso.

\begin{ejemplo}
La variable \texttt{m} declarada al principio es externa, y puede ser vista desde \texttt{fun1()} y \texttt{fun2()}. Sin embargo,
\texttt{fun1()} declara su propia variable m local, y toda operación con \texttt{m} dentro de \texttt{fun1()} se referirá a esta
última. Por otro lado, la variable \texttt{n} es también externa, pero es visible sólo por \texttt{fun2()}, porque \textbf{todo uso
de las variables debe estar precedido por su declaración}. Si apareciera una referencia a la variable \texttt{n} en \texttt{fun1()}, se dispararía un error de compilación. 
\begin{lstlisting}
int m;
int fun1() 
{
	int m;
	m=1;
	...
}
int n;
int fun2() 
{
	m=1;
	...
}
\end{lstlisting}
\end{ejemplo}


\section{Vida de las variables}

Una variable externa se crea al \textbf{momento de carga} del programa, y \textbf{perdura durante toda la ejecución}
del mismo. Una variable local \textbf{se crea y se destruye} a cada invocación de la función donde esté
declarada (excepción: las locales estáticas).

\begin{ejemplo}
Cada vez que \texttt{fun2()} asigna el resultado de \texttt{fun1()} a \texttt{j}, está utilizando el mismo objeto de datos de la misma variable \texttt{j}, porque ésta es externa; pero cada invocación de \texttt{fun1()} crea un nuevo objeto de datos para la variable \texttt{k}, el cual se destruye al terminar esta función.
\begin{lstlisting}
int j;
int fun1()
{
	int k;
	...
}
int fun2()
{
	j=fun1();
}
\end{lstlisting}
\end{ejemplo}

\begin{ejemplo}

La diferencia con el ejemplo anterior es que ahora \texttt{k} es declarada con el modificador \textbf{static}. Esto hace
que \texttt{k} tenga las mismas propiedades de vida que una variable externa. A cada invocación de \texttt{fun1()},
ésta utiliza el mismo objeto de datos, sin modificarlo, para la variable \texttt{k}. Si lee su valor, encontrará el
contenido que pueda haberle quedado de la invocación anterior. Si le asigna un valor, la invocación siguiente de \texttt{fun1()}
encontrará ese valor en \texttt{k}. Este ejemplo muestra que alcance y vida no son propiedades equivalentes en
C. 
\begin{lstlisting}
int j;
int fun1()
{
	static int k;
	...
}
int fun2()
{
	j=fun1();
}
\end{lstlisting}
La propiedad que diferencia ambas instancias de \texttt{k} es la \textbf{clase de almacenamiento}; en el primer caso,
\texttt{k} es local y automática; en el segundo, \texttt{k} es local pero estática. 
\end{ejemplo}


\section{Clases de almacenamiento}
Dependiendo de cómo son almacenados los contenidos de las variables (es decir, en qué lugar del mapa de memoria del programa se mantienen los objetos de datos), éstas pueden tener varias clases de almacenamiento. Una variable \textbf{externa} tiene clase de almacenamiento \textbf{estática}. Una variable \textbf{local} tiene -salvo indicación contraria- clase de almacenamiento \textbf{automática}. Una tercera clase de almacenamiento es la llamada \textbf{registro}. La clase de almacenamiento determina, como se vio recién, la vida de las variables.

\begin{description}
	\item[Variables estáticas] Las variables estáticas comienzan su vida al tiempo de carga del programa, es decir, aun antes de que
se inicie la ejecución de la función main(). Existen durante todo el tiempo de ejecución del programa.
Son \textbf{inicializadas con ceros binarios}, salvo que exista otra inicialización explícita. Son las variables
externas y las locales declaradas static.
 \item [Variables automáticas] Esta clase abarca exclusivamente las variables, declaradas localmente a una función, que no sean
declaradas static. El objeto de datos de una variable automática inicia su existencia al entrar el control a la función donde
está declarada, y muere al terminar la función. \textbf{No son inicializadas} implícitamente, es decir, contienen
\textbf{basura} salvo que se las inicialice explícitamente.
\item [Variables registro] Una variable registro no ocupará memoria, sino que será mantenida en un registro del procesador.
\end{description}

\begin{ejemplo}
\noindent
\begin{itemize}
	\item Aquí \texttt{m}, por ser externa, tiene clase de almacenamiento \textbf{estática}. 
	\item Las variables \texttt{j}, \texttt{k} y \texttt{l} son locales, pero sólo \texttt{j} es \textbf{automática}. 
	\item La variable \texttt{l} es \textbf{estática} (tiene propiedades de vida similares a las de \texttt{m}). 
		\item Por su parte \texttt{k} es de tipo \textbf{registro}, lo que quiere decir que el compilador, siempre que resulte posible, mantendrá sus contenidos en algún registro de CPU de tamaño adecuado. 
\end{itemize}
\begin{lstlisting}
int m;
int fun()
{
	int j;
	register int k;
	static int l;
	...
}
\end{lstlisting}
\end{ejemplo}


Una declaración \texttt{register} debe tomarse solamente como una \textit{recomendación} hecha por el programador al compilador, ya que no hay garantías de que, al tiempo de ejecución, resulte posible utilizar un registro para esa variable. Más aún, el mismo programa, compilado y corrido en diferentes arquitecturas, podrá utilizar diferentes cantidades de registros para sus variables.

Una variable register tendrá un tiempo de acceso muy inferior al de una variable en memoria, porque
el acceso a un registro de CPU es mucho más rápido. En general resulta interesante que las variables
más frecuentemente accedidas sean las declaradas como register; típicamente, los índices de arrays,
variables de control de lazos, etc. Sin embargo, la declaración register es quizás algo anacrónica, ya que los compiladores modernos ejecutan una serie de optimizaciones que frecuentemente utilizan registros para mantener las variables, aun cuando
no haya indicación alguna por parte del programador.

%TODO cuadro velocidades

La clase de almacenamiento automática es natural para las variables locales; ¿cuál es la idea de declarar variables locales que sean estáticas? Generalmente se desea aprovechar la capacidad de \quotes{recordar la historia} de las variables estáticas, utilizando el valor al momento de la última invocación para producir uno nuevo. Por ejemplo, una función puede contar la cantidad de veces que ha sido llamada.


\begin{ejemplo}
Aquí el lazo while se ejecuta 50 veces. La inicialización (implícita o explícita) de una variable estática se produce una única vez, al momento de carga del programa. Por el contrario, la inicialización (explícita) de una automática se hace al crear cada instancia de la misma (al momento de la entrada del control a la función).

\begin{lstlisting}
int veces()
{
	static int vez=0;
	return ++vez;
}
int fun()
{
	while(veces() <= 50) {
		...
	}
}
\end{lstlisting}
\end{ejemplo}







\section{Variables y mapa de memoria}

De acuerdo a su clase de almacenamiento, las variables aparecen en diferentes regiones del mapa de
memoria del programa en ejecución.
\begin{itemize}
	\item Las variables locales (automáticas) \textbf{se disponen en la pila o stack} del programa.
Debido a la forma de administración de esta zona de la
memoria, existen solamente hasta la finalización de la
función.
\item Las variables estáticas (las externas, y las locales cuando
son declaradas \texttt{static}) se alojan en la \textbf{zona de datos
estáticos}. Esta zona no cambia de tamaño ni pierde sus
contenidos, y queda inicializada al momento de carga del
programa.
\end{itemize}

A medida que una función invoca a otras, las variables locales van apareciendo en el stack, y a medida
que las funciones terminan, el stack se va desalojando en orden inverso a como aparecieron las
variables. Cada función, al recibir el control, toma parte del stack, con los contenidos que hubieran
quedado allí de ejecuciones previas, para alojar allí sus variables. A esto se debe que el programa las
vea inicializadas con basura.

\figura[11]{stack1}{Objetos de datos en el stack.}{stack1.eps}
\figura[11]{stack2}{Objetos de datos en el stack bis.}{stack2.eps}

\begin{ejemplo}
Con el código de la Fig. \ref{fig:stack1}, el estado del stack en momentos sucesivos será: 
\begin{enumerate}
\item Antes de entrar a fun1() se tiene el stack vacío.
\item Al entrar a fun1() se disponen sus variables locales en el stack, en orden de aparición.
\item Al entrar a fun2() se dispone su variable local en el stack.
\item Al salir de fun2() y volver a fun1() se desaloja la variable local de fun2().
\item Al salir de fun1() se desmantela el stack completamente y se vuelve al estado inicial.
\end{enumerate}
\end{ejemplo}

\begin{ejemplo}
Con el código de la Fig. \ref{fig:stack2}, que invoca a dos funciones secuencialmente, el estado del stack en momentos sucesivos será: 
\begin{enumerate}
\item Antes de entrar a fun1() se tiene el stack vacío.
\item Al entrar a fun1() se disponen sus variables locales en el stack, en orden de aparición.
\item Al terminar fun1() se desmantela el stack.
\item Al entrar en fun2() se dispone su variable local, cuyo objeto de datos tendrá \textit{basura} debida al valor de a dejado por fun1().
\item Al salir de fun2() se desmantela su stack completamente y se vuelve al estado inicial.
\end{enumerate}
\end{ejemplo}

\section{Liga}

\begin{ejemplo}
\begin{table}
\centering	
\begin{tabular}{l|l|l}
alfa.c & beta.c & gamma.c \\
\hline
\begin{codecell}
main()
{
	fun1();
	fun2();
}
\end{codecell}
&
\begin{codecell}
int fun1()
{
	...
}
\end{codecell}
&
\begin{codecell}
int fun2()
{
	...
	fun3();
	....
}
int fun3()
{
	...
}
\end{codecell}
\\
\end{tabular}
 \caption{Liga de las variables}
 \label{tab:ejliga} 
\end{table}
\end{ejemplo}

Una vez que un conjunto de unidades de traducción pasa exitosamente la compilación, tenemos un
conjunto de módulos objeto. Cada módulo objeto puede contener, en forma simbólica, pendiente de
resolución, \textbf{referencias} a variables o funciones definidas en otros módulos.
La propiedad de las variables y funciones que permite que el linker encuentre la \textbf{definición} de un
objeto para aparearlo con su \textbf{referencia} es la \textbf{liga externa}. Tienen liga externa las \textbf{variables externas y
las funciones}, de modo que todas éstas pueden ser referenciadas desde otras unidades de traducción.

El concepto de liga externa es importante cuando el proyecto de desarrollo abarca varias unidades de
traducción que deben dar lugar a un ejecutable. Aprovechando la propiedad de liga externa de las
funciones, se puede ubicar cada definición de función, o un conjunto de ellas, en un archivo separado.
Esto suele facilitar el mantenimiento y aportar claridad a la estructura de un proyecto de desarrollo.

En el ejemplo dado en Cuadro \ref{tab:ejliga}, \texttt{fun1()}, \texttt{fun2()} y \texttt{fun3()} están definidas en unas unidades de traducción distintas de la de \texttt{main()}. El fuente \textbf{alfa.c} es capaz de dar origen a un programa ejecutable (porque contiene el punto de
entrada al programa), pero solamente si al momento de linkedición se logra que el linker resuelva las
referencias pendientes a \texttt{fun1()} y a \texttt{fun2()} (que no están definidas en \textbf{alfa.c}). Por motivos similares,
las referencias en \textbf{gamma} necesitan de las definiciones en \textbf{beta} al momento de linkedición.

En la práctica logramos esto de varias maneras.
\begin{enumerate}
	\item O bien, con:
\begin{lstlisting}
gcc alfa.c beta.c gamma.c -o alfa
\end{lstlisting}

que significa \quotes{compilar separadamente los tres fuentes, linkeditarlos juntos y al ejecutable resultado
renombrarlo como \textbf{alfa}}; 
\item o bien con:

\begin{lstlisting}
gcc -c alfa.c
gcc -c beta.c
gcc -c gamma.c
gcc alfa.o beta.o gamma.o -o alfa
\end{lstlisting}

que es la misma tarea pero distribuida en etapas separadas;
\item o bien preparando un archivo \textbf{makefile} indicando este modo de construcción e invocar a \textbf{make}.
\end{enumerate}

La excepción a la regla de liga externa se produce cuando las variables externas o funciones son
declaradas con el modificador static. Este modificador cambia el tipo de los objetos a liga interna. Un
objeto que normalmente sería de liga externa, declarado como static, pasa a ser visible únicamente
dentro de la unidad de traducción donde ha sido declarado.
Esta particularidad permite realizar, en cierta medida, ocultamiento de información. Si una unidad de
traducción utiliza variables externas o funciones de su uso privado, que no deben hacerse visibles
desde afuera, puede declarárselas static, con lo cual se harán inaccesibles a toda otra unidad de
traducción. El caso típico se presenta cuando se desea hacer opacas las funciones que implementan un
tipo de datos abstracto, haciéndolas de liga interna mientras que las funciones públicas (las de interfaz)
se dejan con liga externa.


\begin{ejemplo}
\begin{table}
\centering	
\begin{tabular}{l|l|l}
iota.c & kappa.c & lambda.c \\
\hline
\begin{codecell}
main()
{
	fun1();
	fun2();
}
\end{codecell}
&
\begin{codecell}
int fun1()
{
	...
}
static int fun3()
{
	...
}
\end{codecell}
&
\begin{codecell}
int fun2()
{
	...
	fun3();
	...
}
\end{codecell}
\\
\end{tabular}
 \caption{Liga de las variables}
 \label{tab:ejliga2} 
\end{table}
\end{ejemplo}

Este ejemplo es casi idéntico al anterior, salvo que la función fun3() ahora está declarada static y por
este motivo no podrá ser vista por el linker para resolver la referencia pendiente de fun2() en
lambda.c. La función fun3() tiene liga interna. Las tres unidades de traducción jamás podrán
satisfacer la compilación.
Finalmente, las variables locales, al ser visibles únicamente dentro de su función, se dice que no
tienen liga (el linker nunca llega a operar con ellas).

\section{Declaraciones y definiciones}
Normalmente una declaración de variable (de la forma \texttt{especificación\_de\_tipo identificador}) funciona
también como definición de la variable. Es decir, no sólo queda advertido el compilador de cuál es el
tipo del objeto que se va a utilizar, sino que también se crea el espacio de memoria (el objeto de datos)
que va a alojar la información asociada.

La excepción a esto son los objetos declarados extern. Cuando la declaración de una variable
cualquiera aparece precedida del modificador extern, ésta indica el tipo asociado, pero no habilita al
compilador para crear el objeto de datos; se trata de una variable cuya definición debe ser encontrada
en otra unidad de traducción. La declaración extern tan sólo enuncia el tipo y nombre de la variable
para que el compilador lo tenga en cuenta.

Una variable externa es visible desde todas las funciones de la unidad de traducción y puede ser
utilizada desde otras. Esto se debe a la propiedad de liga externa de las variables externas: son visibles
al linker como candidatos para resolver referencias pendientes.

El requisito para poder utilizar una variable definida en otra unidad de traducción es declararla con el
modificador extern en aquella unidad de traducción donde se va a utilizar.

Ejemplo


delta.c
int m;
static int n;
int fun1()
{
n=fun2();
...
}
static int fun2()
{
...
eta.c
extern int m;
int fun3()
{
m=fun1();
}
}

El texto delta.c es una unidad de traducción que declara dos variables externas y dos funciones, pero
hace opacas a la variable n y a la función fun2() con el modificador static. La función fun1() puede
utilizar a todas ellas por estar dentro de la misma unidad de traducción, pero fun3(), que está en otra,
sólo puede referenciar a m y a fun1(), que son de liga externa. Para ello debe declarar a m como
extern, o de lo contrario no superará la compilación ("todo uso debe ser precedido por una
declaración").
Si, además, eta.c declarara una variable extern int n, con la intención de referirse a la variable n
definida en delta.c, la referencia no podría ser resuelta a causa de la condición de liga interna de n.
Los usos de funciones (como fun1() en eta.c)pueden aparecer sin declaración previa, pero en este caso
el compilador asumirá tipos de datos default para los argumentos y para el tipo del valor devuelto por
la función (int en todos los casos).

\section{Modificadores especiales}

\begin{description}
	\item[Const] 
	El modificador const indica que una variable no será modificada. Solamente puede inicializarse, al
momento de carga del programa (y debería hacerse así, ya que no hay otra manera de asignarle un
valor).
const int a=12; /* se declara un entero constante, con inicialización */
a++;
/* el compilador no aprobará esta sentencia */
El modificador const también permite expresar, en el prototipo de una función, que un argumento no
podrá ser modificado por la función, aun cuando sea pasado por referencia.
\item [Volatile]
Los compiladores modernos aplican una cantidad de pasos de optimización cuando ven instrucciones
aparentemente redundantes o sin efectos, porque su desplazamiento o eliminación puede implicar
ventajas en tiempo de ejecución o espacio de almacenamiento. Esto es especialmente así si las
instrucciones sospechosas se encuentran dentro de ciclos. El modificador volatile sirve para advertir al
compilador de que una variable será modificada asincrónicamente con la ejecución del programa (por
ejemplo, por efecto de una rutina de atención de interrupciones) y por lo tanto el optimizador no puede
inferir correctamente su utilidad dentro del programa. Esto evitará que el compilador aplique la lógica
de optimización a las instrucciones que involucran a esta variable.

Por ejemplo, el ciclo siguiente podría ser reescrito por un optimizador, extrayendo del ciclo la
asignación \texttt{a=beta} en el entendimiento de que beta no cambiará en ninguno de los pasos del ciclo.
sin optimizar
\begin{lstlisting}
while(!fin) {
a = beta;
b = fun(a);
}
"optimizado"
a = beta;
while(!fin)
b = fun(a);

\end{lstlisting}
Sin embargo, si esperamos que la variable beta cambie por acción de algún agente externo a la rutina
en cuestión, con la declaración previa
\begin{lstlisting}
volatile int beta;
\end{lstlisting}
el compilador se abstendrá de optimizar las líneas donde intervenga beta.

\end{description}

\section{Ejercicios}
\begin{enumerate}
	\item Copie, compile y ejecute el siguiente programa. Posteriormente agregue un modificador static sobre
la variable a y repita la experiencia.
\begin{lstlisting}
int fun()
{
int a;
a = a + 1;
return a;
}
main()
{
printf("%d\n", fun());
printf("%d\n", fun());
}
\end{lstlisting}
\item ¿Qué imprime este programa?
\begin{lstlisting}
int alfa;
int fun()
{
int alfa;
alfa = 1;
return alfa;
}
main()
{
alfa = 2;
printf("%d\n",fun());
printf("%d\n",alfa);
}
\end{lstlisting}
\item ¿Qué imprime este programa?
\begin{lstlisting}
int alfa;
int fun(int alfa)
{
alfa = 1;
return alfa;
}
main()
{
alfa = 2;
printf("%d\n",fun(alfa));
printf("%d\n",alfa);
}
\end{lstlisting}
 \item Copie y compile, juntas, las unidades de traducción que se indican abajo. ¿Qué hace falta para que
la compilación sea exitosa?
fuente1.c
int a;
int fun1(int x)
{
return 2 * x;
}
fuente2.c
main()
{
a = 1;
printf("d\n", fun1(a));
}
\item ¿Qué ocurre si un fuente intenta modificar una variable externa, declarada en otra unidad de
traducción como const? Prepare, compile y ejecute un ejemplo.
\item ¿Qué resultado puede esperarse de la compilación de estos fuentes?
\begin{lstlisting}
header.h
#include <stdio.h>
#define VALOR 6
fuente1.c
#include "header.h"
main()
{
static int c;
printf("%d\n",fun(c));
}
fuente2.c
#include "header.h"
int fun(int x)
{
return VALOR * x;
}
\end{lstlisting}
\item Podemos denotar esquemáticamente que un módulo objeto prueba.o contiene un elemento de datos
x y una función fun(), ambos de liga externa, de esta manera:
prueba.o
x
fun()
Si se tiene un conjunto de archivos y unidades de traducción que se compilarán para formar los
respectivos módulos objeto, ¿cómo se aplicaría la notación anterior al conjunto de módulos objeto
resultantes? Hacer el diagrama para los casos siguientes. ¿Hay colisión de nombres? ¿Hay referencias que el linker no pueda resolver? Cada grupo de fuentes, ¿puede producir un ejecutable?
hdr1.h
a)
b)
c)
d)
fuente1.c
fuente2.c
fuente3.c
#define UNO 1 #include "hdr1.h" #include "hdr1.h" #include "hdr1.h"
#define DOS 2 main() { int fun1(int x) { int a;
extern int a; int b; return x + fun2(x); 
              b = fun1(a); } 
              } static int 
                fun2(int x) { 
                return x + DOS; 
                } 
extern int c; #include "hdr1.h" int a, b, c=1; main() {
extern int int fun1(int x) { int fun2(int x) { int d;
fun1(int p), return fun2(x)+1; return x - 1; d = fun1(3);
fun2(int p); } } }
int fun1(int int fun3(int x) { main() {
return x + return x + 3; int a;
} } a = fun1(a);
int fun2(int static int }
return x + fun2(int x) { 
} return x + 4; 
  } 
static int a int b;
static int b main() {
int fun2(int b = 2;
return x printf(š%dŠ,
} fun1(3));
 }
x) {
1;
x) {
2;
int fun1(int x) {
extern int b;
x = b - fun2(x);
}
= 1;
= 1;
x) {
- a;
\item  Un conjunto de programas debe modelar eventos relativos a un aeropuerto. Se necesita preparar una
implementación de las estructuras de datos y funciones del aeropuerto, para ser usada por los demás
programas. Especifique las variables y funciones (en pseudocódigo) que podrán satisfacer los
siguientes requerimientos. Preste atención a las declaraciones extern y static.
El aeropuerto tendrá cinco pistas.
Se mantendrá un contador de la cantidad total de aviones en el aeropuerto y uno de la cantidad
total de aviones en el aire.
Para cada pista se mantendrá la cantidad de aviones esperando permiso para despegar de ella y la
cantidad de aviones esperando permiso para aterrizar en ella.
Habrá una función para modelar el aterrizaje y otra para modelar el despegue por una pista dada
(decrementando o incrementando convenientemente la cantidad de aviones en una pista dada, en
tierra y en el aire).
Habrá una función para consultar, y otra para establecer, la cantidad de aviones esperando
aterrizar o despegar por cada pista.
Habrá una función para consultar la cantidad de aviones en tierra y otra para consultar la cantidad
de aviones en el aire.

No deberá ser posible que un programa modifique el estado de las estructuras de datos sino a
través de las funciones dichas.
\end{enumerate}
